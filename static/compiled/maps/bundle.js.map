{"version":3,"sources":["static/ts/services/feed.ts","static/ts/services/item.ts","static/ts/components/abstract-item-list.ts","static/ts/components/item-list.ts","static/ts/components/main.ts","static/ts/module.ts"],"names":["FeedService","[object Object]","http_","this","feedsSubject_","rxjs_1","ReplaySubject","feedsFetched_","fetchFeeds_","next","feeds_","obs","get","pipe","operators_1","map","response","json","share","subscribe","data","error","console","notify_","__decorate","core_1","Injectable","http_1","Http","ItemService","items_","itemsSubject_","rxjs_2","itemsFetched_","fetchItems_","id","post","operators_2","updateItem_","updatedItem","idx","findIndex","item","read","length","timestamp","splice","core_2","http_2","feedService_","itemService_","domSanitizer_","refreshing_","markItemAsRead","markItemAsUnread","fid","error_","url","startsWith","bypassSecurityTrustUrl","sanitize","core_3","SecurityContext","URL","path","split","encodeURIComponent","replace","$event","button","rxjs_3","zip","reloadFeeds","reloadItems","ItemList","abstract_item_list_1","AbstractItemList","domSanitizationService_","super","getFeeds","updatedFeeds","f","getAllUnreadItems","updatedItems","key","ctrlKey","altKey","shiftKey","metaKey","refresh","filter","feedId","disabled","core_4","HostListener","KeyboardEvent","Component","selector","template","feed_1","item_1","platform_browser_1","DomSanitizer","Main","core_5","Module","core_6","NgModule","imports","platform_browser_2","BrowserModule","http_3","HttpModule","declarations","main_1","item_list_1","providers","feed_2","item_2","bootstrap","platform","platform_browser_dynamic_1","platformBrowserDynamic","window","location","pathname","enableProdMode","bootstrapModule"],"mappings":"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","file":"../bundle.js","sourcesContent":["import {Feed} from '../types';\n\nimport {Injectable} from '@angular/core';\nimport {Http} from '@angular/http';\nimport {ReplaySubject, Observable} from 'rxjs';\nimport {map, share} from 'rxjs/operators';\n\n/**\n * Service that handles Feeds. Keeps an unsorted list of feeds that have been loaded at some point.\n */\n@Injectable()\nexport class FeedService {\n  private feeds_: Feed[];\n  private feedsSubject_: ReplaySubject<Feed[]> = new ReplaySubject<Feed[]>(1);\n  private feedsFetched_: boolean = false;\n\n  constructor(private http_: Http) {}\n\n  public getFeeds() {\n    if (!this.feedsFetched_) {\n      this.fetchFeeds_();\n    }\n    return this.feedsSubject_;\n  }\n\n  public reloadFeeds(): Observable<any> {\n    if (this.feedsFetched_) {\n      return this.fetchFeeds_();\n    }\n\n    return this.feedsSubject_;\n  }\n\n  // Private methods\n  private notify_() {\n    this.feedsSubject_.next(this.feeds_);\n  }\n\n  private fetchFeeds_(): Observable<any> {\n    this.feedsFetched_ = true;\n\n    const obs = this.http_.get('/api/feeds/list')\n        .pipe(map(response => response.json()), share());\n    \n    obs.subscribe(data => {\n      if (data.error) {\n        console.error(data.error);\n        return;\n      }\n      this.feeds_ = data;\n      this.notify_();\n    }, error => console.error(error));\n\n    return obs;\n  }\n}\n\n","import {Injectable} from '@angular/core';\nimport {Http} from '@angular/http';\nimport {Observable, ReplaySubject} from 'rxjs';\nimport {map, share} from 'rxjs/operators';\nimport {Item} from '../types';\n\n/**\n * Service that handles Items.\n * Keeps a sorted list of items that have been unread since the last refresh.\n * This array will include read items or items for disabled/hidden feeds.\n */\n@Injectable()\nexport class ItemService {\n  /**\n   * May include read items if they've been marked read since the last refresh.\n   */\n  private items_: Item[] = [];\n  private itemsSubject_: ReplaySubject<Item[]> = new ReplaySubject<Item[]>(1);\n  private itemsFetched_: boolean = false;\n\n  constructor(private http_: Http) {}\n  /*\n   * --- Naive, brute force solution\n   * -- have some ideas to improve this but they're probably not worth the\n   * complexity\n   * // Gets unread items from fro\n   * getUnreadItems()\n   * getItemsForFeed()\n   *\n   * private updateSubject\n   * updates()\n   * updatesForFeed(fid)\n   * updatesForCategory?\n   * updatesForItem(id, fid)\n   *\n   * ItemUpdates\n   * {fid : [items changed]}\n   */\n\n  // getItemsSubject\n  public getAllUnreadItems() {\n    if (!this.itemsFetched_) {\n      this.fetchItems_();\n    }\n    return this.itemsSubject_;\n  }\n\n  public markItemAsRead(id: number): Observable<Item> {\n    var obs = this.http_.post('/api/items/' + id + '/read', '')\n                  .pipe(map(response => response.json()), share());\n\n    obs.subscribe(data => {\n      if (data.error) {\n        console.error(data.error);\n        return;\n      }\n      this.updateItem_(data);\n    }, error => console.error(error));\n\n    return obs;\n  }\n\n  public markItemAsUnread(id: number): Observable<Item> {\n    const obs = this.http_.post('/api/items/' + id + '/unread', '')\n                    .pipe(map(response => response.json()), share());\n\n    obs.subscribe(data => {\n      if (data.error) {\n        console.error(data.error);\n        return;\n      }\n      this.updateItem_(data);\n    }, error => console.error(error));\n\n    return obs;\n  }\n\n  public reloadItems(): Observable<any> {\n    if (this.itemsFetched_) {\n      return this.fetchItems_();\n    }\n    return this.itemsSubject_;\n  }\n\n  // Private methods\n  private notify_() { this.itemsSubject_.next(this.items_); }\n\n  // Updates an existing item or adds an unread item to the list.\n  private updateItem_(updatedItem: Item) {\n    var idx = this.items_.findIndex((item: Item) => item.id === updatedItem.id);\n    if (idx != -1) {\n      this.items_[idx] = updatedItem;\n    } else if (!updatedItem.read) {\n      idx = 0;\n      while (idx < this.items_.length &&\n             this.items_[idx].timestamp > updatedItem.timestamp) {\n        idx++;\n      }\n      this.items_.splice(idx, 0, updatedItem);\n    } else {\n      return;\n    }\n\n    this.notify_();\n  }\n\n  private fetchItems_(): Observable<any> {\n    this.itemsFetched_ = true;\n\n    const obs = this.http_.get('/api/items/list')\n                    .pipe(map(response => response.json()), share());\n\n    obs.subscribe(data => {\n      if (data.error) {\n        console.error(data.error);\n        return;\n      }\n      this.items_ = data;\n      this.notify_();\n    }, error => console.error(error));\n\n    return obs;\n  }\n}\n","import {FeedService} from '../services/feed';\nimport {ItemService} from '../services/item';\nimport {Feed, Item} from '../types';\n\nimport {Component, OnInit} from '@angular/core';\nimport {Observable, zip} from 'rxjs';\nimport {DomSanitizer, SafeResourceUrl} from '@angular/platform-browser';\nimport {SecurityContext} from '@angular/core';\n\nexport abstract class AbstractItemList {\n  protected feeds_: {[key:number]:Feed} = {};\n  protected items_: Item[] = [];\n  private refreshing_: boolean = false;\n  private error_: Error | null; \n\n  constructor(\n    protected feedService_: FeedService,\n    protected itemService_: ItemService,\n    private domSanitizer_: DomSanitizer) {\n  }\n\n  abstract ngOnInit(): void;\n\n  markItemAsRead(id: number): Observable<Item> {\n    return this.itemService_.markItemAsRead(id);\n  }\n  \n  markItemAsUnread(id: number): Observable<Item> {\n    return this.itemService_.markItemAsUnread(id);\n  }\n\n  getFeed(fid: number): Feed {\n    return this.feeds_[fid];\n  }\n\n  getItems(): Item[] {\n    return this.items_;\n  }\n\n  isRefreshing(): boolean {\n    return this.refreshing_;\n  }\n\n  getError(): Error | null {\n    return this.error_;\n  }\n\n  getItemUrl(item: Item): SafeResourceUrl | string | null {\n    if (item.url.startsWith('magnet:')) {\n      return this.domSanitizer_.bypassSecurityTrustUrl(item.url);\n    }\n    return this.domSanitizer_.sanitize(SecurityContext.URL, item.url);\n  }\n\n  // TODO: factor this out into some kind of plugin system\n  getItemMobileUrl(item: Item): string | undefined {\n    if (item.url.startsWith(\"https://manga.madokami.al/\")) {\n      let path = item.url.split(\"madokami.al\")[1];\n      path = encodeURIComponent(path);\n      path = path.replace(/%2F/g, \"%252F\");\n      return \"https://manga.madokami.al/reader/\" + path;\n    }\n  }\n\n  handleItemClick($event: MouseEvent, item: Item) {\n    if ($event.button == 1 && !item.read) {\n      this.markItemAsRead(item.id);\n    }\n  }\n\n  refresh() {\n    this.refreshing_ = true;\n\n    zip(this.feedService_.reloadFeeds(), this.itemService_.reloadItems())\n        .subscribe(() => {\n          this.error_ = null;\n          this.refreshing_ = false;\n        }, (error) => {\n          this.error_ = error;\n          this.refreshing_ = false;\n        });\n  }\n}\n","import {FeedService} from '../services/feed';\nimport {ItemService} from '../services/item';\nimport {Feed, Item} from '../types';\nimport {AbstractItemList} from './abstract-item-list';\n\nimport {Component, OnInit, HostListener} from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser';\n\n@Component({\n  selector: 'item-list',\n  templateUrl: '/static/templates/item-list.html'\n})\n\n/**\n * An item list that shows unread items for enabled feeds, or items that were marked read since the last refresh.\n * This is the most optimized case.\n */\nexport class ItemList extends AbstractItemList {\n  constructor(\n      feedService_: FeedService,\n      itemService_: ItemService,\n      domSanitizationService_: DomSanitizer) {\n    super(feedService_, itemService_, domSanitizationService_)\n  }\n  \n  ngOnInit() {\n    this.feedService_.getFeeds().subscribe(updatedFeeds => {\n      this.feeds_ = {};\n      for (var f of updatedFeeds) {\n        this.feeds_[f.id] = f;\n      }\n    });\n    this.itemService_.getAllUnreadItems().subscribe(updatedItems => {\n      this.items_ = updatedItems;\n    });\n  }\n\n  @HostListener('window:keydown', ['$event'])\n  handleKeydown($event : KeyboardEvent) {\n    if ($event.key == 'r' && !$event.ctrlKey &&\n        !$event.altKey && !$event.shiftKey &&\n        !$event.metaKey) {\n      this.refresh();\n    }\n  }\n\n  getItems() {\n    return this.items_.filter(\n      item => this.feeds_[item.feedId] && !this.feeds_[item.feedId].disabled);\n  }\n}\n","import {ItemList} from './item-list';\n\nimport {Component} from '@angular/core';\n\n@Component({\n  selector: 'main',\n  templateUrl: '/static/templates/main.html'\n})\n\nexport class Main {}\n\n","import {Main} from './components/main';\nimport {ItemService} from './services/item';\nimport {FeedService} from './services/feed';\nimport {ItemList} from './components/item-list';\n\nimport {NgModule, enableProdMode} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\nimport {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\nimport {HttpModule} from '@angular/http';\n\n@NgModule({\n  imports: [BrowserModule, HttpModule],\n  declarations: [Main, ItemList],\n  providers: [FeedService, ItemService],\n  bootstrap: [Main]\n})\n\nclass Module {\n}\n\nconst platform = platformBrowserDynamic();\nif (!window.location.pathname.startsWith('/dev/')) {\n  enableProdMode();\n}\nplatform.bootstrapModule(Module);\n\n"]}